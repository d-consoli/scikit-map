% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/train.spm.R
\name{train.spm}
\alias{train.spm}
\title{train.spm}
\usage{
train.spm(
  df.tr,
  target.variable,
  parallel = TRUE,
  predict_type = NULL,
  folds = folds,
  method.list = NULL,
  n_evals = n_evals,
  plot.workflow = FALSE,
  var.imp = TRUE,
  meta.learner = NULL,
  crs,
  coords = c("x", "y")
)
}
\arguments{
\item{df.tr}{}

\item{target.variable}{}

\item{parallel}{}

\item{predict_type}{}

\item{folds}{}

\item{method.list}{}

\item{n_evals}{}

\item{plot.workflow}{}

\item{var.imp}{}

\item{meta.learner}{}

\item{crs}{}
}
\value{
train.model

summary

var.imp
}
\description{
This is the abstract base class for training objects like [TaskClassif] and [TaskRegr].
For example, for a classification task columns must be marked as ID, df, target column.
train.spm  it multiple models/learners depending on the
class() of the target.variable and for now only returns a
trained model function so later on we could use it to train a new dataset.
}
\examples{
## Splitting training (tr) and test (ts) sets and defining generic variables
## Meuse Demo
library(sp)
library(mlr3verse)
demo(meuse, echo=FALSE)

# Meuse Demo ----
demo(meuse, echo=FALSE)
pr.vars = c("x","y","dist","elev","soil","lead")
df <- as.data.frame(meuse)
# df <- df[complete.cases(df[,pr.vars]),pr.vars]
df = na.omit(df[,])
summary(is.na(df))
crs = "+init=epsg:3035"
#target.variable = "landuse"
target.variable = "lead"
# define generic var ----
smp_size <- floor(0.5 * nrow(df))
set.seed(123)
train_ind <- sample(seq_len(nrow(df)), size = smp_size)
df.tr <- df[train_ind, c("x","y","dist","elev","soil","lead")]
df.ts <- df[-train_ind, c("x","y","dist","elev","soil")]
folds = 2
n_evals = 3
newdata = df.ts
# plot var ----
colorcut. = c(0,0.01,0.03,0.07,0.15,0.25,0.5,0.75,1)
colramp. = colorRampPalette(c("wheat2","red3"))
xbins. = 20
# coords=c("x","y")
# id = deparse(substitute(df.tr))
# MODELS ----
tr = train.spm(df.tr, target.variable = target.variable, folds = folds ,n_evals = n_evals, plot.workflow = TRUE, coords, crs, var.imp)
train.model= tr[[1]]
var.imp = tr[[2]]
var.imp
summary = tr[[3]]
summary

predict.variable = predict.spm(train.model, newdata)
predict.variable
plt = accuracy.plot.spm(x = df.tr[,target.variable], y = predict.variable, rng = "norm")

# predicct for all var
prd.all = predict.spm(train.model, df)
str(prd.all)
df$leadp = prd.all
coordinates(df) <- ~x+y
proj4string(df) <- CRS("+init=epsg:28992")
# creat raster out of output
is.projected(df)
extent(df)
r = raster::raster(extent(df), crs=crs(df), resolution=150)
values(r) = 0
# plot(r)
lead.r=rasterize(df, r, 'leadp', fun=mean)
plot(lead.r)

}
\author{
\href{https://opengeohub.org/people/mohammadreza-sheykhmousa}{Mohammadreza Sheykhmousa} and  \href{https://opengeohub.org/people/tom-hengl}{Tom Hengl}
}
