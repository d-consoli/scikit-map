---
title: " demo: eumap Rpackage functionalities"
author: "Mohammadreza Sheykhmousa (mohammadreza.sheykhmousa@OpenGeoHub.org)"
date: "Last compiled on: `r format(Sys.time(), '%d %B, %Y')`"
output: 
   rmarkdown::md_document:
    toc: true
    toc_depth: 3
bibliography: ./tex/refs.bib
csl: ./tex/apa.csl  
fig_caption: yes
link-citations: yes
twitter-handle: opengeohub
header-includes:
- \usepackage{caption}
---

[1.1]: http://i.imgur.com/tXSoThF.png (twitter icon with padding)
[1]: https://twitter.com/sheykhmousa
Follow me on [![alt text][1.1]][1]

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, comment = '', fig.width = 6, fig.height = 6)
```

```{r , include=FALSE}
library(knitr)
```


```{r ,echo=FALSE}
remotes::install_git("https://gitlab.com/geoharmonizer_inea/eumap.git", subdir = 'R-package')
```



```{r, echo=FALSE, warning=FALSE}
hook_output <- knit_hooks$get("output")
knit_hooks$set(output = function(x, options) {
   lines <- options$output.lines
   if (is.null(lines)) {
     return(hook_output(x, options))  # pass to default hook
   }
   x <- unlist(strsplit(x, "\n"))
   more <- "..."
   if (length(lines)==1) {        # first n lines
     if (length(x) > lines) {
       # truncate the output, but add ....
       x <- c(head(x, lines), more)
     }
   } else {
     x <- c(more, x[lines], more)
   }
   # paste these lines together
   x <- paste(c(x, ""), collapse = "\n")
   hook_output(x, options)
 })
```

## Introduction
`eumap` aims at providing easier access to EU environmental maps.
Basic functions train a spatial prediction model using [mlr3 package](https://mlr3.mlr-org.com/), [@mlr3], and related extensions in the [mlr3 ecosystem](https://github.com/mlr-org/mlr3/wiki/Extension-Packages) [@casalicchio2017openml; @MichelLang2020mlr3book], 
which includes spatial prediction using [Ensemble Machine Learning](https://koalaverse.github.io/machine-learning-in-R/stacking.html#stacking-software-in-r) taking spatial coordinates and spatial cross-validation into account. 
In a nutshell one can `train` an arbitrary `s3` **(spatial)dataframe** in `mlr3` ecosystem by defining *df* and *target.variable* i.e., response.
main functions are as the following:

## `train_spm` 

1. `train_spm` will automatically perform `classification` or `regression` tasks and the output is a `train_model` which later can be used to predict `newdata`.It also provides *summary* of the model and *variable importance* and *response*.
The rest of arguments can be either pass or default values will be passed. `train_spm` provides four scenarios:

  1.1. `classification` task with **non spatial** resampling methods
  1.2. `regression` task with **non spatial** resampling methods
  1.3. `classification` task with **spatial** resampling methods
  1.4. `regression` task with **spatial** resampling methods

## `predict_spm`

1. Prediction on a new dataset using `train_model`,
2. User needs to set`df.ts = test set` and also pass the `train_model`. 

## `plot_spm` 

1. Accuracy plot in case of regression task (donâ€™t use it for classification tasks for obvious reason),
 
**Warning:** most of functions are optimized to run in parallel by default. This might result in high RAM and CPU usage.

The following examples demonstrates spatial prediction using the `sic97` data set:

## Required packages

```{r , warning=FALSE}
start_time <- Sys.time()
ls <- c("lattice", "raster", "plotKML", "ranger", "mlr3verse", "BBmisc", "knitr", "bbotk",
    "hexbin", "stringr", "magrittr", "sp", "ggplot2", "mlr3fselect", "mlr3spatiotempcv",  "tidyr", "lubridate", "R.utils", "terra","rgdal",
    "FSelectorRcpp", "future", "future.apply", "mlr3filters", "EnvStats", "grid", "mltools","gridExtra","yardstick","plotKML", "latticeExtra","devtools","progressr")
new.packages <- ls[!(ls %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages, repos="https://cran.rstudio.com", force=TRUE)
```

## sic97 dataset

```{r ,results='hide', warning=FALSE}
#sic97 source data: https://rdrr.io/github/Envirometrix/landmap/man/sic1997.html
library("landmap")  
data(sic1997) 
sic97 <- na.omit(sic1997)
sic97 <- sic1997$swiss1km[c("CHELSA_rainfall","DEM")]
df <- data.frame(sic97)
#let's create some fake cov
df$test1 <- log10(df$DEM)*53.656 
df$test2 <- cos(df$DEM)*-0.13 
df$test3 <- sin(df$DEM)**31 
df$test4 <- (df$DEM)**-5.13 
df$test5 <- runif(1:nrow(df))
df$test6 <- (df$DEM/2**4)**6 
df$test7 <- (df$x)**-1
df$test8 <- (df$y)*3
df$test9 <- (df$CHELSA_rainfall)**-1
df$test10 <-((df$CHELSA_rainfall)*13/34)
df$test11 <- runif(1:nrow(df))/0.54545
df$test12 <- sqrt(runif(1:nrow(df))) 
```

## split training (tr) and test (ts) set  
```{r }
smp_size <- floor(0.5 * nrow(df))
set.seed(123)
train_ind <- sample(seq_len(nrow(df)), size = smp_size)
df.tr <- df[train_ind,]
df.ts <- df[-train_ind, ]
newdata = df.ts
```


## Loading required libraries:
```{r, message=FALSE, warning=FALSE}
library("mlr3verse")#
library("mlr3spatiotempcv")#
library("sp")#
library("grid")#
library("hexbin")#
library("BBmisc")#
library("lattice")#
library("gridExtra")#
library("MLmetrics")
library("yardstick")#
library("latticeExtra")#
library("eumap")
library("ppcor")
library("progressr")
library("checkmate")

```

## `train_spm`

`train_spm` fits multiple models/learners depending on the `class` of the **target.variable** and for returns a `trained model`, **var.imp**, **summary** of the model, and **response** variables. `trained model` later can predict a `newdata` set. 

```{r ,results='hide', warning=FALSE}
tr = eumap::train_spm(df.tr, target.variable = target.variable , folds = folds , n_evals = n_evals , crs = "+init=epsg:28992")
```

`train_spm` results:

1st element is the *trained model*:

```{r ,results='hide', warning=FALSE}
train_model= tr[[1]]
```
2nd element is the *variable importance*:
```{r}
var.imp = tr[[2]]
var.imp

```
3rd element of the summary of the *trained model*:
```{r}
summary = tr[[3]]
summary
```

4th element is the predicted values of our trained model
note: here we just show start and the ending values
```{r , output.lines= -(4:145)}
response = tr[[4]]
response
```
```{r}
vlp = tr[[5]]
vlp
```

## `predict_spm`

prediction on `newdata` set
```{r}
predict.variable = eumap::predict_spm(train_model, newdata)

```
### predicted values for the *newdata* set:
note: here we just show start and the ending values
```{r ,output.lines= -(3:3200)}
pred.v = predict.variable[1]
pred.v
```
```{r ,results='hide'}
valu.imp= predict.variable[[2]]
valu.imp
```

## `plot_spm` 
in case of regression task,

```{r, fig.align="center", fig.width=6, fig.height=6, fig.cap="Accuracy plot"}
plt = plot_spm(x = df.tr[,target.variable], y = pred.v[[1]], z = valu.imp, gmode  = "root" , gtype = "correlation", gvar_imp = "TRUE")
```


```{r , echo=FALSE, warning=FALSE}

df.ts$leadp = predict.variable
coordinates(df.ts) <- ~x+y
proj4string(df.ts) <- CRS("+init=epsg:28992")
# creat raster out of output
gridded(df.ts) = TRUE

```
## raster grid 
make a map using ensemble machine learning with spatial cross validation for the predicted variables e.g., *lead* (in this case) 
```{r, fig.align="center", fig.width=6, fig.height=6, fig.cap="Raster grid"}
plot(df.ts[,"leadp"])
points(sic97, pch="+")
```

## Croatia tile

### Overlay Demonstration

we will use the eumap package to overlay all the points of a vector layer (geopackage file) on several raster layers (geotiff files), using the SpaceOverlay and SpaceTimeOverlay classes to handle with timeless and temporal layers, respectively. In our dataset the elevation and slope, based on digital terrain model, are timeless and the landsat composites (7 spectral bands, 4 seasons and 3 percentiles) and night light (VIIRS Night Band) layers are temporal (from 2000 to 2020).

### reading Croatia data
Our dataset refers to 1 tile, located in Croatia, extracted from a tiling system created for European Union (7,042 tiles) by [GeoHarmonizer Project](https://opendatascience.eu/).

```{r}
tif1.lst = list.files("/data/eumap/sample-data/R-sample-tiles/9529", pattern=".tif", full.names=TRUE, recursive=TRUE) 
df = readOGR("/data/eumap/sample-data/R-sample-tiles/9529_croatia_landcover_samples.gpkg")
df <- as.data.frame(df)
df$Date = format.Date(as.Date(paste(df$survey_date), format="%Y/%m/%d"), "%Y-%m-%d")
df$row.id = 1:nrow(df)
```

### `stripe_years`

```{r}
begin.tif1.lst = sapply(tif1.lst, function(i){strip_years(i, type="begin")})
end.tif1.lst = sapply(tif1.lst, function(i){strip_years(i, type="end")})
unique(end.tif1.lst)
```

### `extract_tif` 

```{r}
cores = ifelse(parallel::detectCores()<length(tif1.lst), parallel::detectCores(), length(tif1.lst))
ov.pnts <- parallel::mclapply(1:length(tif1.lst), function(i){ eumap::extract_tif(tif=tif1.lst[i], df, date="Date", date.tif.begin=begin.tif1.lst[i], date.tif.end=end.tif1.lst[i], coords=c("coords.x1","coords.x2")) }, mc.cores=cores)
gc()
ov.pnts = ov.pnts[!sapply(ov.pnts, is.null)]
```
```{r}
str(ov.pnts[1:6])
```

## Space-Time Overlay

For the temporal layers, the points should be filtered by year and overlayed on the right raster files. The SpaceTimeOverlay class implements this approach using the parameter:
- timeless_data: The result of SpaceOverlay (GeoPandas DataFrame) - col_date: The column that contains the date information (2018-09-13)
- dir_temporal_layers: The directory where the temporal raster files are stored, organized by year
```{r, results='hide', warning=FALSE}
library(data.table)
commcols <- Reduce(intersect, lapply(ov.pnts, names))
L.dt <- lapply(ov.pnts, function(x) setkeyv(data.table(x), commcols))
cmt <- do.call(cbind, L.dt) 
uq.lst <- unique(colnames(cmt))
cm.tif <- cmt[, .SD, .SDcols = unique(names(cmt))]
df <- as.data.table(df)
cm <- Reduce(merge,list(df,cm.tif))
tt = cbind(cm,df$year)
saveRDS(tt, "/data/eumap/sample-data/R-sample-tiles/9529/9529_croatia_samples.rds")
```


```{r}
str(tt)
```

## pre-processing Croatia data

```{r}
cm.croatia <- readRDS("/data/eumap/sample-data/R-sample-tiles/9529/9529_croatia_samples.rds")

str(cm.croatia)
df <-  cm.croatia
df$lc_class <- as.factor(df$lc_class)
crs = "+init=epsg:3035"
target.variable = "lc_class"
df <- df %>% group_by_if(is.character, as.factor)
df$row.id <- NULL
df$survey_date <- NULL
df$lucas <- NULL
df$Date <- NULL
df$id <- NULL
df$year <- NULL
df$tile_id <- NULL
df$confidence <- NULL
df$V2 <- NULL
df$coords.x1 <- NULL
df$coords.x2 <- NULL
colnames(df)
# colnames(df)[4] <- "x"
# colnames(df)[5] <- "y"
coordinate_names = c("x","y")
smp_size <- floor(0.5 * nrow(df))
set.seed(123)
train_ind <- sample(seq_len(nrow(df)), size = smp_size)
df.tr <- df[train_ind, ]
df.ts <- df[ -train_ind,]
folds = 5  #you can change the number to get a better result
n_evals = 5  #you can change the number to get a better result
newdata = df.ts
 
```

## train_spm
```{r, output.lines= -(4:145)}
tr = eumap::train_spm(df.tr, target.variable = target.variable , folds = folds , n_evals = n_evals)
train_model= tr[[1]]
var.imp = tr[[2]]
length(var.imp )
summary = tr[[3]]
summary
pred.model = tr[[4]]
pred.model
```

## predict_spm
Prediction; raster map

```{r , eval=F, echo=T}
year.span = c(2000:2020)
#
aq =c("/data/eumap/sample-data/R-sample-tiles/9529/timeless/dtm_elevation.tif" ,"/data/eumap/sample-data/R-sample-tiles/9529/timeless/dtm_slope.tif")
for (i in 1:2) {
  tif1.lst = list.files(paste0('/data/eumap/sample-data/R-sample-tiles/9529/',year.span[i]), pattern=".tif", full.names=TRUE, recursive=TRUE)
  tif1.lst <- append(tif1.lst, aq)
  out.tif <- paste0("/data/eumap/img/R/","land_cover_9529_croatia_",year.span[i],".tif")
  br01 = stack(tif1.lst)
  newdata = as(br01, "SpatialGridDataFrame")
  predict.ts = predict_spm(train_model, newdata@data)
  newdata$pred = predict.ts
  newdataa <- newdata ## copy and make new raster object
  newdataa@data$pred <- as.numeric(levels(newdataa@data$pred))[newdataa@data$pred]
  writeGDAL(newdataa["pred"], out.tif, drivername="GTiff", type="Int16", mvFlag = -32768 ,options=c("COMPRESS=DEFLATE"))
}
```

### get ride of small classess in prediction
optional

```{r , eval=F, echo=T}

xg <- summary(newdata$pred, maxsum=(1+length(levels(newdata$pred))))
str(xg)
selg.levs <- attr(xg, "names")[xg > 5]  
attr(xg, "names")[xg <= 5] #drop classes with less than 5 pixels
newdata$pred[which(!newdata$pred %in% selg.levs)] <- NA
newdata$pred <- droplevels(newdata$pred)
str(summary(newdata$pred, maxsum=length(levels(newdata$pred))))


```

```{r, fig.align="center", fig.width=6, fig.height=6, fig.cap="LC map"}
plot(runif(10,1,10),runif(10,100,1e6))
```



## References

