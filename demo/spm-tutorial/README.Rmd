---
title: " demo: eumap Rpackage functionalities"
author: "Mohammadreza Sheykhmousa (mohammadreza.sheykhmousa@OpenGeoHub.org)"
date: "Last compiled on: `r format(Sys.time(), '%d %B, %Y')`"
output: 
   rmarkdown::md_document:
    toc: true
    toc_depth: 3
bibliography: ./tex/refs.bib
csl: ./tex/apa.csl  
fig_caption: yes
link-citations: yes
twitter-handle: opengeohub
header-includes:
- \usepackage{caption}
---

[1.1]: http://i.imgur.com/tXSoThF.png (twitter icon with padding)
[1]: https://twitter.com/sheykhmousa
Follow me on [![alt text][1.1]][1]

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, comment = '', fig.width = 8, fig.height = 8)
```

```{r , include = FALSE}
library(knitr)
```


```{r , message=FALSE,warning=FALSE,results='hide'}
remotes::install_git("https://gitlab.com/geoharmonizer_inea/eumap.git", subdir = 'R-package')
```

```{r, echo=FALSE, warning = FALSE}
hook_output <- knit_hooks$get("output")
knit_hooks$set(output = function(x, options) {
   lines <- options$output.lines
   if (is.null(lines)) {
     return(hook_output(x, options))  # pass to default hook
   }
   x <- unlist(strsplit(x, "\n"))
   more <- "..."
   if (length(lines)==1) {        # first n lines
     if (length(x) > lines) {
       # truncate the output, but add ....
       x <- c(head(x, lines), more)
     }
   } else {
     x <- c(more, x[lines], more)
   }
   # paste these lines together
   x <- paste(c(x, ""), collapse = "\n")
   hook_output(x, options)
 })
```

## Introduction
`eumap` aims at providing easier access to EU environmental maps.
Basic functions train a spatial prediction model using [mlr3 package](https://mlr3.mlr-org.com/), and related extensions in the [mlr3 ecosystem](https://github.com/mlr-org/mlr3/wiki/Extension-Packages) [@casalicchio2017openml; @MichelLang2020mlr3book], 
which includes spatial prediction using [Ensemble Machine Learning](https://koalaverse.github.io/machine-learning-in-R/stacking.html#stacking-software-in-r) taking spatial coordinates and spatial cross-validation into account. 
In a nutshell one can `train` an arbitrary `s3` **(spatial)dataframe** in `mlr3` ecosystem by defining *df* and *target.variable* i.e., response.
main functions are as the following:

## `train_spm` 

1. `train_spm` will automatically perform `classification` or `regression` tasks and the output is a `train_model` which later can be used to predict `newdata`.It also provides *summary* of the model and *variable importance* and *response*.
The rest of arguments can be either pass or default values will be passed. `train_spm` provides four scenarios:

  1.1. `classification` task with **non spatial** resampling methods,
   
  1.2. `regression` task with **non spatial** resampling methods,
  
  1.3. `classification` task with **spatial** resampling methods,
  
  1.4. `regression` task with **spatial** resampling methods.

## `predict_spm`

1. Prediction on a new dataset using `train_model`,
2. User needs to set`df.ts = test set` and also pass the `train_model`. 

## `plot_spm` 

1. Accuracy plot in case of regression task (donâ€™t use it for classification tasks for obvious reason).

The following examples demonstrates spatial prediction using the [sic97](https://wiki.52north.org/pub/AI_GEOSTATS/AI_GEOSTATSData/SIC97_description_01.pdf) data set:

### Required packages

```{r , warning=FALSE}
start_time <- Sys.time()
ls <- c("lattice", "raster", "plotKML", "ranger", "mlr3verse",
    "hexbin", "sp", "ggplot2", "mlr3spatiotempcv",  "rgdal",
    "FSelectorRcpp", "future", "future.apply", "mlr3filters", "grid", "mltools","gridExtra","yardstick", "latticeExtra","progressr")
new.packages <- ls[!(ls %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages, repos="https://cran.rstudio.com", force=TRUE)
```

### sic97 dataset

```{r ,results='hide', warning=FALSE}
#sic97 source data: https://rdrr.io/github/Envirometrix/landmap/man/sic1997.html
library("landmap")  
library("sp")  
data(sic1997) 
sic97 <- na.omit(sic1997)
sic97 <- sic1997$swiss1km[c("CHELSA_rainfall","DEM")]
df <- data.frame(sic97)
# adding covariats i.e, principal component. (from landmap package https://github.com/Envirometrix/landmap)
sp.df <- df
coordinates(sp.df) <- ~x+y
proj4string(sp.df) <- CRS("+init=epsg:28992")
gridded(sp.df) = TRUE
pc <- spc(sp.df)
df$pc1 <- pc@predicted$PC1
df$pc2 <- pc@predicted$PC2
#let's create some fake cov
df$test1 <- log10(df$DEM)*53.656
df$test2 <- cos(df$DEM)*-0.13
df$test3 <- sin(df$DEM)**31
df$test11 <- runif(1:nrow(df))/0.54545
df$test12 <- sqrt(runif(1:nrow(df)))
```

### spliting the data 

```{r }
smp_size <- floor(0.5 * nrow(df))
set.seed(123)
train_ind <- sample(seq_len(nrow(df)), size = smp_size)
df.tr <- df[train_ind,]
df.ts <- df[-train_ind, ]
newdata = df.ts
```


### Loading required libraries:

```{r, message=FALSE, warning=FALSE}
library("mlr3verse")#
library("mlr3spatiotempcv")#
library("grid")#
library("hexbin")#
library("BBmisc")#
library("lattice")#
library("gridExtra")#
library("MLmetrics")
library("yardstick")#
library("latticeExtra")#
library("eumap")
library("ppcor")
library("progressr")
library("checkmate")
library("future")

```

### `train_spm`

`train_spm` fits multiple models/learners depending on the `class` of the **target.variable** and returns a `trained model`, **variable importance**,  **summary** of the model, and **response** variables. `trained model` later can predict a `newdata` set. 

```{r ,results='hide', warning=FALSE}
tr = eumap::train_spm(df.tr, target.variable = "CHELSA_rainfall", folds = 5, n_evals = 3, crs = "+init=epsg:4326")
```

- 1st element contains the *trained model*,
- 2nd element contains the *variable importance*,
- 3rd element contains a summary of the *trained model*,
- 4th  element contains the *predicted values* of our trained model,
- 5th  element contains the ranking of the  *important variables*.

```{r ,results='hide', warning=FALSE}
train_model= tr[[1]]
var.imp = tr[[2]]
summary = tr[[3]]
response = tr[[4]]
vlp = tr[[5]]
target = tr[[6]]

```
### `predict_spm`

prediction on *newdata* set

```{r}
predict.variable = eumap::predict_spm(train_model, newdata)

```

### predicted values for the *newdata* set:

```{r ,output.lines= c(1:10)}
predict.variable = predict_spm(train_model, df.ts)
pred.v = predict.variable[[1]]
valu.imp= predict.variable[[2]]
pred.v
#valu.imp
```

### `plot_spm` 
- Variable importance

```{r, fig.align="center", fig.width=6, fig.height=6, fig.cap="var.imp"}
plt = plot_spm(df, gmode  = "norm" , gtype = "var.imp")
```

- Accuracy plot

```{r, fig.align="center", fig.width=6, fig.height=6, fig.cap="Accuracy plot"}
plt = plot_spm(df, gmode  = "norm" , gtype = "accuracy")
```
### spatial prediction on *rainfall*

```{r  warning=FALSE}
predict.variable = predict_spm(train_model, df)
df$rainP = predict.variable[[1]]
coordinates(df) <- ~x+y
proj4string(df) <- CRS("+init=epsg:28992")
# creat raster out of output
gridded(df) = TRUE
```

make a map using ensemble machine learning with spatial cross validation for the predicted variables e.g., *rainfall* (in this case). 

```{r, fig.align="center", fig.width=6, fig.height=6, fig.cap="Raster grid"}
plot(df[,"rainP"])
```

## Croatia tile

### Overlay Demonstration

we will use the eumap package to overlay all the points of a vector layer (geopackage file) on several raster layers (geotiff files), using the SpaceOverlay and SpaceTimeOverlay classes to handle with timeless and temporal layers, respectively. In our dataset the elevation and slope, based on digital terrain model, are timeless and the landsat composites (7 spectral bands, 4 seasons and 3 percentiles) and night light (VIIRS Night Band) layers are temporal (from 2000 to 2020).

### reading Croatia data
Our dataset refers to 1 tile, located in Croatia, extracted from a tiling system created for European Union (7,042 tiles) by [GeoHarmonizer Project](https://opendatascience.eu/).

```{r}
library(rgdal)
tif1.lst = list.files("/data/eumap/sample-data/R-sample-tiles/9529", pattern=".tif", full.names=TRUE, recursive=TRUE) 
df = readOGR("/data/eumap/sample-data/R-sample-tiles/9529_croatia_landcover_samples.gpkg")
df <- as.data.frame(df)
df$Date = format.Date(as.Date(paste(df$survey_date), format="%Y/%m/%d"), "%Y-%m-%d")
df$row.id = 1:nrow(df)
```

### `stripe_years`
- strips the file names of the *.tif list file to specific years from 2000 to 2020

```{r}
begin.tif1.lst = sapply(tif1.lst, function(i){strip_years(i, type="begin")})
end.tif1.lst = sapply(tif1.lst, function(i){strip_years(i, type="end")})
unique(end.tif1.lst)
```

### `extract_tif` 
- spatio-temporal overlay of data points and *.tif data.

```{r, warning=FALSE}
cores = ifelse(parallel::detectCores()<length(tif1.lst), parallel::detectCores(), length(tif1.lst))
ov.pnts <- parallel::mclapply(1:length(tif1.lst), function(i){ eumap::extract_tif(tif=tif1.lst[i], df, date="Date", date.tif.begin=begin.tif1.lst[i], date.tif.end=end.tif1.lst[i], coords=c("coords.x1","coords.x2")) }, mc.cores=cores)
gc()
ov.pnts = ov.pnts[!sapply(ov.pnts, is.null)]
```

- Structure of the Top 3 row of the data points.

```{r}
str(ov.pnts[1:3])
```

## Space-Time Overlay

For the temporal layers, the points should be filtered by year and overlayed on the right raster files. The SpaceTimeOverlay class implements this approach using the parameter:
- timeless_data: The result of SpaceOverlay (GeoPandas DataFrame) - col_date: The column that contains the date information (2018-09-13)
- dir_temporal_layers: The directory where the temporal raster files are stored, organized by year.

```{r, results='hide', warning=FALSE}
library(data.table)
commcols <- Reduce(intersect, lapply(ov.pnts, names))
L.dt <- lapply(ov.pnts, function(x) setkeyv(data.table(x), commcols))
cmt <- do.call(cbind, L.dt) 
uq.lst <- unique(colnames(cmt))
cm.tif <- cmt[, .SD, .SDcols = unique(names(cmt))]
df <- as.data.table(df)
cm <- Reduce(merge,list(df,cm.tif))
tt = cbind(cm,df$year)
#saveRDS(tt, "/data/eumap/sample-data/R-sample-tiles/9529/9529_croatia_samples.rds")
```

- To partially demonstrate the structure of the data:

```{r,output.lines= c(1:10)}
str(tt)
```

### (analysis ready) data

```{r, warning=FALSE,message=FALSE}
library(dplyr)
cm.croatia <- readRDS("/data/eumap/sample-data/R-sample-tiles/9529/9529_croatia_samples.rds")
df <-  cm.croatia
df$lc_class <- as.factor(df$lc_class)
df <- df %>% group_by_if(is.character, as.factor)
df$row.id <- NULL
df$survey_date <- NULL
df$lucas <- NULL
df$Date <- NULL
df$id <- NULL
df$year <- NULL
df$tile_id <- NULL
df$confidence <- NULL
colnames(df)[2] <- "x"
colnames(df)[3] <- "y"
#coordinate_names = c("x","y")
df <- as.data.frame(df)
smp_size <- floor(0.5 * nrow(df))
set.seed(123)
train_ind <- sample(seq_len(nrow(df)), size = smp_size)
df.tr <- df[train_ind, ]
df.ts <- df[ -train_ind,]
newdata = df.ts
 
```

## `train_spm`

```{r, output.lines= (1:10), warning=FALSE, results='hide'}
library(mlr3verse)
library(future)
library(progressr)
library(checkmate)
tr = eumap::train_spm(df.tr, target.variable = "lc_class" , folds = 5 , n_evals = 3)
```

- storing values of *tr* for further use.

```{r}
train_model= tr[[1]]
var.imp = tr[[2]]
summary = tr[[3]]
response = tr[[4]]
vlp = tr[[5]]
target = tr[[6]]
summary
```
- variable importance plot; (shows only 10% of important variables)

```{r, fig.align="center", fig.width=6, fig.height=6, fig.cap="Accuracy plot"}
varImp = barplot(var.imp[1:(round(length(var.imp)*0.1)+1)], horiz = TRUE, las = 1,cex.names = 0.6)
  title(main = "variable importance", font.main = 4)
  
```

## `predict_spm`
Prediction; raster map

```{r , eval=F, echo=T}
year.span = c(2000:2020)
#
aq =c("/data/eumap/sample-data/R-sample-tiles/9529/timeless/dtm_elevation.tif" ,"/data/eumap/sample-data/R-sample-tiles/9529/timeless/dtm_slope.tif")
for (i in 1:2) {
  tif1.lst = list.files(paste0('/data/eumap/sample-data/R-sample-tiles/9529/',year.span[i]), pattern=".tif", full.names=TRUE, recursive=TRUE)
  tif1.lst <- append(tif1.lst, aq)
  out.tif <- paste0("/data/eumap/img/R/","land_cover_9529_croatia_",year.span[i],".tif")
  br01 = stack(tif1.lst)
  newdata = as(br01, "SpatialGridDataFrame")
  predict.ts = predict_spm(train_model, newdata@data)
  newdata$pred = predict.ts
  newdataa <- newdata ## copy and make new raster object
  newdataa@data$pred <- as.numeric(levels(newdataa@data$pred))[newdataa@data$pred]
  #writeGDAL(newdataa["pred"], out.tif, drivername="GTiff", type="Int16", mvFlag = -32768 ,options=c("COMPRESS=DEFLATE"))
}
```

- Removing small classes in prediction
(*optional*)

```{r , eval=F, echo=T}

xg <- summary(newdata$pred, maxsum=(1+length(levels(newdata$pred))))
str(xg)
selg.levs <- attr(xg, "names")[xg > 5]  
attr(xg, "names")[xg <= 5] #drop classes with less than 5 pixels
newdata$pred[which(!newdata$pred %in% selg.levs)] <- NA
newdata$pred <- droplevels(newdata$pred)
str(summary(newdata$pred, maxsum=length(levels(newdata$pred))))

```

```{r, fig.align="center", fig.width=6, fig.height=6, fig.cap="LC map"}

```



## References

